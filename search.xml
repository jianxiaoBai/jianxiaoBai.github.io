<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo 笔记]]></title>
    <url>%2F2017-07-06%2FHexo%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本操作常用命令 命令 说明 hexo n “我的博客” hexo new “我的博客” #新建文章 hexo p hexo publish hexo g hexo generate#生成 hexo s hexo server #启动服务预览 hexo d hexo deploy#部署 hexo d #部署 #可与hexo g合并为 hexo d -g 服务器 命令 说明 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 完成后部署 命令 说明 hexo g #生成静态网页 hexo d #开始部署 模版 命令 说明 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 写作 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 示例： 12345678title: 搭建个人博客layout: postdate: 2020-01-01 12:00:00comments: truecategories: Blogtags: [Hexo]words: Hexo, Blogdescription: 搭建个人博客还是要用 Hexo 书写语法自定义图片大小12标准：&#123;% img [class names] /path/image [width] [height] [title text [alt text]] %&#125;例如：&#123;% img /imgs/baiyan.jpg 100 50 %&#125; 突破容器宽度限制的图片的三种方式当使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上 提升图片的吸引力 。 123&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&#123;% fullimage /image-url, alt, title %&#125;&#123;% fi /image-url, alt, title %&#125; Bootstrap Callout1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default 默认 primary 提示 success 成功 info 提示 warning 警告 danger 危险 从书中引用新：DevDocs现在附带语法高亮。http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 文本居中的引用3中方式123&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&#123;% cq %&#125;人一切的痛苦，本质上都是对自己的无能的愤怒&#123;% endcq %&#125; 推荐]]></content>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE 快捷键]]></title>
    <url>%2F2017-07-06%2F%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[各类开发工具中一般有很多快捷键，但常用的就那么一些，以下种类快捷键前后是根据我的 使用频率 进行排序 Sublime选择类 快捷键 作用 Ctrl+D 匹配所选中的下一个相同文本 Alt+F3 匹配所选中的所有相同文本 Ctrl+Enter 在下一行插入新行 Ctrl+Shift+Enter 在上一行插入新行 Ctrl+Shift+← 向左单位性地选中文本 Ctrl+Shift+→ 向右单位性地选中文本 Ctrl+左键 添加多光标 滚轮按住向下滑 添加多光标 Ctrl+Shift+↑ 将光标所在行和上一行代码互换 Ctrl+Shift+↓ 将光标所在行和下一行代码互换 Ctrl+← 向左单位性地移动光标，快速移动光标 Ctrl+→ 向右单位性地移动光标，快速移动光标 shift+↑ 向上选中行 shift+↓ 向下选中行 Shift+← 向左选中文本 Shift+→ 向右选中文本 Ctrl+M 光标移动至括号起始位置 Ctrl+Shift+M 选中括号内的内容 编辑类 快捷键 功能 Ctrl+Z 撤销 Ctrl+Shift+z 恢复撤销 Ctrl+Shift+D 复制光标所在整行，插入到下一行 Tab 向右缩进 Shift+Tab 向左缩进 Ctrl+F2 设置书签 Ctrl+/ 注释单行 Ctrl+Shift+/ 注释多行 搜索类 快捷键 功能 Ctrl+F 打开底部搜索框，查找关键字 Ctrl+shift+F 在 文件夹 内查找所要搜索的内容 Ctrl+Shift+P 打开命令框 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码 Ctrl+P 打开搜索框，可输入当前项目中的文件名，快速搜索文件 窗口类 快捷键 功能 alt+Shift+ Number 窗口分屏，恢复默认 Number 屏（非小键盘的数字） Ctrl+K+B 开启/关闭侧边栏 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页 Ctrl+PageDown 向左切换当前窗口的标签页 Ctrl+PageUp 向右切换当前窗口的标签页]]></content>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 笔记]]></title>
    <url>%2F2017-06-23%2Fes6%2F</url>
    <content type="text"><![CDATA[前言 对阮一峰的ES6的内容进行的 提炼 对其中的内容进行了 简化 对一些我个人认为较复杂且不常用的功能或概念 采取忽略 对ES6 不熟悉 的同学 可能会有一点帮助 如笔记整理有错误还请留言 指出 深度阅读请访问 http://es6.ruanyifeng.com let 与 const代码块：外层作用域无法读取内层作用域中的变量 共同点 只在块级作用域中有效 暂时性死区 不允许重复声明 不存在变量提升 不同点 const 声明时 必须赋值 并且 值不可变 关于解析赋值数组的数组的元素是按 次序排列 的，变量的取值要与位置匹配 典型例子 1234567891011121314let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // []let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 设置默认值 ：解构赋值允许指定默认值。 123456789let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'-------------------------------------------function f() &#123; console.log('aaa');&#125;// 函数 f 没有执行，因为 x 的值是 1 不属于 undefinedlet [x = f()] = [1]; 对象的对象的属性虽没有次序，但变量必须与属性同名 典型例子 123456789101112131415161718192021222324252627282930let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined-------------------------------------------/* 如果变量名与属性名不一致，必须写成下面这样。*//***********注意:对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。************/let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'-------------------------------------------/***********下面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。************/let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 设置默认值 ：解构赋值允许指定默认值。 12345678910111213141516var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 函数的 经典范例 12345678910111213/* 函数move的参数是一个对象，如果通过解构，得不到变量x或y的值，那么x和y等于默认值。*/function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]. 因为 x 有值 就会赋值 ，y 没有值 就是默认值move(&#123;&#125;); // [0, 0]move(); // [0, 0]-------------------------------------------/* undefined就会触发函数参数的默认值。 */[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 基本用途交换变量的值 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 ap结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789101112131415161718192021var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world-------------------------------------------/* 如果只想获取键名，或者只想获取键值，可以写成下面这样。 */// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 关于类型的扩展字符串扩展–模板字符串123456789101112131415161718192021// 普通字符串输出： '\n' 换行，trim（） 消除字符前后空格` In JavaScript '\n' is a line-feed. `.trim()// 字符串中嵌入变量 : `$&#123;&#125;`var name = "Bob";`Hello $&#123;name&#125;,`// 大括号内部可以进行运算var x = 1，y = 2;`$&#123;x + y&#125;`// "3"// 大括号内部可以调用函数function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 正则的扩展–后行断言目前，有一个 提案 ，引入后行断言。 123456/* 先行断言 ,只匹配百分号之前的数字 *//\d+(?=%)/.exec('of US presidents 100% have been male') //["100"]/* 后行断言 ,只匹配百分号之后的数字 *//(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') //["100"] 数值的扩展 方法 作用 Number.isNaN() 判断值是否为NaN，为NaN返回true Number.parseInt()/parseFloat() ES6将这俩个全局方法移植到了Number对象上 Number.isInteger() 判断值是否为整数 Math.trunc() 返回整数部分 Math.sign() 判断一个数是正数、负数、0，对应返回值 +1、-1、0 数组的扩展Array.from(对象，_对象处理函数，_this指向)可将 数组的对象 和 可遍历的对象 转换为数组结构 1234567891011121314/* 类似数组的对象 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']/******************************************************//* 可遍历的对象 */let namesSet = new Set(['a', 'b']) // nameSet &#123;'a','b'&#125;Array.from(namesSet) // ['a', 'b'] Array.of()将一组值转换为数组 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3,2).length // 2 find()、findIndex()、includes() find 方法，用于找出 第一个 符合条件的数组中的值，否则返回 undefined findIndex 返回 第一个 符合条件的位置，否则返回-1。 includes() 和 indexOf() 很像，前者返回布尔值后者返回数值 123456[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组的遍历entries() 、keys()、values() 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 函数的扩展函数参数的默认值 函数内部是不可以再次声明形参 函数的执行时形参会形成作用域 函数体内&gt;形参内&gt;全局内 12345678910111213141516171819202122/* 如实例化时x、y没有传入参数，那么x、y的默认值就是 0 */function Point(x = 0, y = 0) &#123; this.x = x; this.y = y; //&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125;/* 调用时不传参数会报错 */function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5 , 因为只传了一个空对象，y有默认值 x等同于声明了未定义，即undefinedfoo() // 报错. 因为没有传参数， 那么形参的声明的默认值就不会正确执行，即报错/* 调用时不传参数不会报错 */function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined, 5 这样就不会报错了 rest 形参 rest 只能在形参中的最后一位 函数的length属性不包括 rest 函数 1234567function mypush(array, ...items) &#123; items.forEach(item=&gt;&#123; array.push(item); &#125;);&#125;var a = [];mypush(a, 1, 2, 3); // a = [1,2,3]; 扩展运算符的应用小应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 取得最大值 */Math.max(...[14, 3, 77])/* * 将一个数组添加到另一个数组的尾部 */var arr1 = [0, 1, 2], arr2 = [3, 4, 5];arr1.push(...arr2);/* * 生成指定时间 */new Date(...[2015, 1, 1]);/* * 合并数组 */[...arr1, ...arr2, ...arr3]/* * 与解构赋值结合 */const [first, ...rest] = [1, 2, 3, 4, 5];first //1rest //[2, 3, 4, 5]const [first, ...rest] = [];first //undefinedrest //[]const [first, ...rest] = ["foo"];first //"foo"rest //[]/* * 函数的返回值 * 从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 */va r dateFields = readDateFields(database);var d = new Date(...dateFields);// 将字符串转为真正的数组[...'hello']// [ "h", "e", "l", "l", "o" ] 实现了 Iterator 接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为 真正的数组。 12345678910111213141516171819var nodeList = document.querySelectorAll('div');var array = [...nodeList];/* * 扩展运算符可以将伪数组nodeList 转换真正的数组， * 原因就在于 NodeList 对象实现了 Iterator 接口。 */let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;let arr = [...arrayLike];// 报错/** * arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。 * 这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 */ Map和Set结构，Generator函数因此只要 具有Iterator接口的对象，都可以使用扩展运算符 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567var go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 箭头函数使用注意 箭头函数体内的 this 指向的是 父作用域 不可以当作构造函数 不可以使用 arguments 对象，可以用 rest 参数代替。 不可以使用 yield 命令 基本使用12345678910111213141516171819/* 一个形参 */var f = v =&gt; v;/* 多个形参 */var sum = (num1, num2) =&gt; num1 + num2;/* 由于大括号被解释为代码块，所以返回对象时要加上小括号 */var getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;);/* 多条语句卸载大括号内 */var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;/* 箭头函数与变量解构结合使用 */const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 绑定 this 绑定 this 是用来取代call、apply、bind调用 函数绑定运算符是并排的两个冒号（::） 12345678foo::bar; /* 等同于 */ bar.bind(foo);foo::bar(...arguments); /* 等同于 */ bar.apply(foo, arguments);/* 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 */var method = obj::obj.foo; /* 等同于 */ var method = ::obj.foo;var log = ::console.log; /* 等同于 */ var log = console.log.bind(console); 尾调用(Tail Call)ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 尾调用是函数式编程 的一个重要概念，就是指 某个函数 最后一步 以 return 的方式调用另一个函数 123456789101112/* 尾调用 */function f(x)&#123; return g(x);&#125;/* 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。*/function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 对于尾调用优化的理解 每函数执行时在内存中形成调用帧（保存调用位置和内部变量等信息），调用帧的释放 取决于该函数是否执行了return ，系统默认会自执行 return， 但前提是需要等待程序执行完毕时，那在这个过程中累积的调用帧无疑加大了内存的开销。所以结尾处以 return 形式调用另一个函数 可以使 调用帧及时释放以减少无用的内存浪费 对象的扩展属性的简洁表示法1234567891011121314151617/* 对象内可以使用变量名 */var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;function f(x, y) &#123;/*内部默认执行了 x = 1,y = 2 ，所以形参也是变量*/ return &#123;x, y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;/* 对象内方法的简写 */var o = &#123; method() &#123; return "Hello!"; &#125;&#125;; 应用场景场景一 ：对象中直接放一个变量 12345678var birth = '2000/01/01';var Person = &#123; name: '张三', birth, hello() &#123; console.log('我的名字是', this.name); &#125;&#125;;Person.birth // '2000/01/01' 场景二 ：这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; var x = 1; var y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 场景三 ：CommonJS 模块输出变量 ，就非常合适使用简洁写法。 123456789101112131415161718192021var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式12345678910111213141516171819202122/* 例子一 */let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;;obj.foo // trueobj.abc // 123/* 例子二 */var lastWord = 'last word';var a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 属性表达式定义方法名1234567891011121314151617181920let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi/* 属性名表达式与简洁表示法，不能同时使用 */// 报错var foo = 'aaa';var aaa = 'abc';var baz = &#123; [foo] &#125;;// 正确var foo = 'aaa';var baz = &#123; [foo]: 'abc'&#125;;baz.aaa // abc Object.is()比较俩个值是否相等,和 === 类似 . Object.js(1,2) 等同于 1 === 2 Object.assign()Object.assign方法用于合并对象，第一个参数是目标对象 ，后面的参数都是源对象。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 应用场景 为对象添加属性 123456class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125;/* 通过Object.assign方法，将x、y属性添加到 Point 类的对象实例中 */ 为对象添加方法 1234567891011121314151617181920/* *通过 Object.assgin 函数将 aaa、bbb函数 添加到 SomeClass.prototype 原型中。 */Object.assign(SomeClass.prototype, &#123; aaa(arg1, arg2) &#123; ··· &#125;, bbb() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.aaa = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.bbb = function () &#123; ···&#125;; 合并多个对象 12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;/* DEFAULTS对象是默认值，options对象是用户提供的参数。 */function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // &#123;logLevel: 0, outputFormat: "html"&#125;&#125; 属性的遍历 方法 作用 for…in 遍历自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj) 返回数组，（不含继承的）所有可枚举属性（不含 Symbol 属性）。 Object.getOwnPropertyNames(obj) 返回自身对象的一个数组，不含 Symbol 属性，但是包括不可枚举属性）。 Object.getOwnPropertySymbols(obj) 返回自身对象的一个数组，含所有 Symbol 属性。 Reflect.ownKeys(obj) 返回自身对象的一个数组，不管属性名是 Symbol 或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历 为数值的属性，按照 数字排序 。 其次遍历 字符串的属性，按照生成时间排序。 最后遍历 Symbol 值的属性，按照生成时间排序。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] proto 属性 Object.getprototypeOf() == 读取一个对象的原型对象 Object.setprototypeOf() == 设置一个对象的原型对象 Object.keys()/values()/entries()可将对象中所有的 键或值 单独分离进行独立出来 1234var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj) // ["foo", "baz"]Object.values(obj) // ["bar", 42]Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ] 对象的扩展运算符1234567891011121314151617181920212223let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;/*******************************/let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2/*******************************/let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;/** * 扩展运算符可以用于合并两个对象。 */let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 扩展运算符花样操作 1234567let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); Symbol 为了从根本上解决命名冲突 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值 目前总共7种分别是: undefined、null、Nubmber、String、Boolean、Object、 Symbol Set 和 Map 数据结构Set基本用法 类似于数组 ，但成员的值 没有重复 的 可接受 任何数组 作为参数进行初始化 Set 本身是一个构造函数，用来生成 Set 数据结构。 123const set = new Set([1,1,2,3,4,4]);[...set]// [1, 2, 3, 4] Set 属性 属性 作用 构造函数 Set.prototype.constructor 成员总数 Set.prototype.size Set 方法 操作方法 作用 add(value)： 添加某个值，返回Set结构本身。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 has(value)： 返回一个布尔值，表示该值是否为Set的成员。 clear()： 清除所有成员，没有返回值。 遍历方法 作用 keys() / values()： 返回键名的遍历器 entries()： 返回键和值，但键和值都一样 forEach()： 使用回调函数遍历每个成员 12345678910111213141516171819202122232425let set = new Set(['red', 'green', 'blue']);/* set 的默认方法就是 set.values */for (let item of set) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]/* forEach对每个成员执行某种操作，没有返回值。 */let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 应用数组去重12345678//方法一let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2]//方法二let arr = Array.from(new Set([1,2,2,3,4]))// [1, 2, 3, 4] 数组的 map 和 filter 方法结合Set轻松实现并、交、差集1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Map解决对象的键只能是字符串的痛点（null、undefined都可以），Map 结构提供了“值和值”的对应 基本用法123456789101112/* 注意是 二维数组的方式 [ [],[],[] ]*/const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.set(o, 'content')map.has('name') // truemap.get('name') // "张三"map.size // 3 注意 :Map 结构只会对 有对象引用的 , 才将其视为一个键。 12345678910111213141516171819202122232425262728const map = new Map();map.set(['a'], 555);map.get(['a'])// undefined 的原因是 set 时候的 ['a'] 和 get 时候的 ['a'] 在内存地址中不是同一个位置。/*****************************************************/const map = new Map();const k1 = ['a'];const k2 = ['a'];/* 链式写法 */map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222/* 因为k1 的值是对象 ，而对象是引用类型储存在堆中， set 和 get 用的 都是一个引用地址，所以就能取到对应的值, k1 和 k2 的值虽然一样但是 存储的引用地址不一样，so 不会冲突 */ 属性和方法属性：size ，返回 Map结构成员总数。 方法： 操作的 作用 set(key,value)： 设置 key 对应的键值,可采用链式写法 get(key)： 读取 key 对应的键值，找不到返回 undefined has(value)： 返回一个布尔值，表示该值是否为 Map 的成员。 delete(value)： 删除某个值，返回一个布尔值，表示删除是否成功。 clear()： 清除所有成员，没有返回值。 遍历的 作用 keys() 返回键名的遍历器 values() 返回键值的遍历器 entries()： （默认）返回键和值的遍历器 forEach()： 遍历map的所有成员 forEach方法还可以接受第二个参数，用来绑定 this。 123456789const reporter = &#123; report: function(key, value) &#123; console.log("Key: %s, Value: %s", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 与其他数据结构的互相转换Map 转为数组 直接用扩展运算符就可以很方便的进行转化 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组转为 Map 直接将数组传入 Map 构造函数，就可以转化为 Map 。 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Map 转为对象 如果所有 Map 的键都是字符串，它可以转为对象。 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 123456789101112131415161718function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;'/************************************************************//* 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 */function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' JSON 转 Map JSON 转为 Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; Proxy （代理）详细介绍 在目标对象之前设置了一个中间人，外界访问该对象时都必须先通过这个中间人，这种机制就可以对外界的访问进行过滤和改写 ES6 原声提供 Proxy 构造函数，用来生成 proxy 实例。 1var proxy = new Proxy(target, handler); new Proxy(): 表示生成一个 Proxy实例 target : 参数表示所要 拦截的目标对象 handler: 参数也是一个对象，用来 定制拦截行为。 应用场景Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 1234567891011121314151617181920/* 新建了一个 Web 服务的接口，这个接口返回各种数据。*/const service = createWebService('http://example.com/data');service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;);/***********************************************//*Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。*/function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+'/' + propKey); &#125; &#125;);&#125; Promise（承诺） 对象了解 Promise Promise 是异步编程的一种解决方案 Promise 是一个保存着一个未来才会结束的事件 Promise 的俩个特点 只有异步操作的 结果，才能决定当前是哪一种 状态 Pending（进行中） Resolved（已完成，又称 Fulfilled） Rejected（已失败） 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 状态的改变只有两种可能：从 Pending 变为 Resolved 和 从 Pending 变为 Rejected。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本操作ES6 规定，Promise对象是一个 构造函数 ，用来生成Promise实例。 Promise构造函数 接受一个函数作为参数，该函数的两个参数也是函数分别是resolve和reject。 resolve 函数： 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 12345678910111213141516171819/* 生成 promise 实例 */var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);/** * Promise实例生成以后，可以用then方法 分别指定Resolved状态 和 Reject状态的回调函数。 */promise.then(function(value) &#123; // 成功时&#125;, function(error) &#123; // 失败时 （该函数可选）&#125;); 一个 Promise 对象的简单例子 一个用Promise对象实现的 Ajax 操作的例子 Promise.prototype.then() then方法是定义在原型对象Promise.prototype上的 then(Resolved状态回调函数,Rejected 状态的回调函数) then方法返回的是一个 新的 Promise实例,因此可以采用链式写法，即then方法后面再调用另一个then方法。 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection)的别名，用于 指定发生错误时的回调函数。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 例子 12345678var promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);/* promise抛出一个错误，就被catch方法指定的回调函数捕获。 */// Error: test 俩种捕捉错误的方法 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 其他深度阅读 Promise.all()Promise.all用于将多个 Promise 实例，包装成一个新的 Promise 实例。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve 方法就起到这个作用。 Promise.reject()也会返回一个新的 Promise 实例，该实例的状态为 rejected。 Iterator 和 for…of循环Iterator 概念 ES6中有四种数据集合分别是：数组、对象(没有Iterator接口)、Map、Set 用户如果想组合使用这些数据，就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是为各种不同的数据结构 提供统一的访问机制的接口 。 任何数据结构只要部署Iterator接口 ，就可以完成遍历操作。 Iterator的三个作用 为各种数据结构，提供一个统一访问接口 ； 使得数据结构的成员能够按 某种次序排列 ； Iterator接口主要 配合for...of 。 默认的 Iterator 接口 默认的Iterator接口 部署在数据结构的 Symbol.iterator属性 也就是，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”。 Symbol.iterator就是 默认生成遍历器的函数,执行它就会返回一个遍历器。 原生具备 Iterator 接口的数据结构：Array、Map、Set、String、TypedArray、函数的 arguments 对象 123456789/* 具备原生 Iterator ：Array */let arr = ['a', 'b', 'c'];/*执行它就会返回一个遍历器,根本特征就是具有 next 方法 */let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合12345678910111213141516171819202122232425262728293031/** * 1.解析赋值 */let [first, ...rest] = ['a','b','c'];// first='a'; rest=['b','c'];/** * 2.扩展运算符 */let arr = ['b', 'c'];['a', ...arr, 'd']// ['a', 'b', 'c', 'd']/** * 3. yield* * yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 */let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 遍历器对象的 return(),throw()遍历器对象具有next、_return、_throw方法。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。 for…of 循环for…of循环 内部调用 的是数据结构的Symbol.iterator方法，所以只要数据结构只要部署了Symbol.iterator属性，就可以用for…of循环遍历它的成员 与其他遍历语法比较 for循环 没有 fo…of 简洁 forEach 无法中途跳出forEach循环，break命令或return命令都不能奏效 for…in 主要是为遍历对象而设计的，不适用于遍历数组 Generator 函数的语法基本概念Generator 函数是 ES6 提供的一种 异步编程解决方案 ，语法行为与传统函数 完全不同 。 Generator 函数有多种理解角度。 从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 同时执行 Generator 函数会 返回一个遍历器对象 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数形式上的两个特征。 function 与函数名的中间有一个星号； 函数体内部使用yield表达式，定义不同的内部状态（ yield 在英语里的意思就是“产出”）。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以 暂停执行的函数,yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，暂停并将 紧跟在yield后面的那个 表达式的值 ，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到return语句为止，并以对象行使返回return语句后面的表达式的值 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield 于 return 的区别 yield 函数暂停执行，下一次再从该位置继续向后执行，具备记忆 一个函数里面，只能执行一次return语句，但是可以执行多个yield表达式。 正常函数只能返回一个值，因为只能执行一次return； 函数可以返回一系列的值，因为可以有任意多个yield。 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 1234567function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; next 方法的参数next方法的参数 表示 上一个yield表达式的返回值 1234567891011121314151617181920212223242526272829303132333435/* 简单例子 */ function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125; &#125; var g = f(); g.next() // &#123; value: 0, done: false &#125; g.next() // &#123; value: 1, done: false &#125; /* 当next方法带一个参数true时， 变量reset就被重置为这个参数（即true）， 因此i会等于-1，下一轮循环就会从-1开始递增。 */ g.next(true) // &#123; value: 0, done: false &#125;/* 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子 */ function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result'; &#125; let genObj = dataConsumer(); genObj.next(); // Started genObj.next('a') // 1. a genObj.next('b') // 2. b Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 1234567891011121314function* inner() &#123; yield 'hello!';&#125;function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // "open"gen.next().value // "hello!"gen.next().value // "close" 作为对象属性的 Generator 函数12345678910111213/* myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 */ let obj = &#123; * myGeneratorMethod() &#123; // ··· &#125; &#125;;/* 与上面的写法是等价的 */ let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125; &#125;; 应用场景 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构 Generator 函数的异步应用异步编程对 JavaScript 语言太重要,因为 Javascript 语言的执行环境是 “单线程”的. 详细阅读 async 函数 一句话，它就是 Generator 函数的语法糖 详细阅读 Class 的基本语法ES6 的class写法只是让对象原型的 写法更加清晰 、更接近主流面向对象编程 的语法而已。 深度阅读 Class的继承 Module 的语法概述 历史上，JavaScript 一直没有模块体系，直接导致了对开发大型的、复杂的项目造成了巨大障碍。 ES6 实现了 模块功能 ，而且实现得 相当简单 ，完全可以取代其他规范。 ES6 模块的设计思想是尽量的静态化，使得 编译时 就能 确定 模块的 依赖关系 ，以及输入和输出的变量。 CommonJS 与 ES6 模块的区别 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 &quot;use strict&quot; 严格模式主要有以下限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用 with 语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] eval 不会在它的外层作用域引入变量 eval 和 arguments 不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用 arguments.callee 不能使用 arguments.caller 禁止 this 指向全局对象 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 增加了保留字（比如 protected 、static 和 interface ） export 命令模块功能主要由两个命令构成：export 命令用于 规定 模块的 对外接口 ，import 命令用于 输入其他模块提供的功能。 输出变量 一个模块就是一个独立的文件，其内部所有变量 外部无法获取。 如果希望外部能够读取模块内部的某个变量，就必须使用 export输出该变量。 12345678910111213// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;/* 上下写法等同 */// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 输出函数或类1234 export function multiply(x, y) &#123; return x * y;&#125;;// 输出 multiply 函数 使用as关键字重命名123456789function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;;/* 使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。*/ 特别注意export 规定是: 对外的接口 与 模块内部的变量 建立一一 对应关系 。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 1234567891011121314/** * 1.import命令，用于加载profile.js文件，并从中输入变量。 * 2.import命令接受一对大括号，里面指定要从其他模块导入的变量名。 * 3.大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 */// main.jsimport &#123;firstName, lastName, year&#125; from './profile';/* import命令要使用 as 关键字，将输入的变量重命名。*/// import &#123; lastName as surname &#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 知识点 from指定模块文件的位置时可以是相对或绝对路径，.js可以省略 如果只是模块名，不带有路径，那么必须有配置文件，告诉 JS 引擎该模块的位置。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 模块的整体加载整体加载：即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 12345678910111213/* 模块的整体加载 */import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14));/* 上下同等 */import &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); export default 命令为模块指定默认输出12345678910111213// export-default.jsexport default function () &#123; console.log('foo');&#125;/** * 模块文件export-default.js，它的默认输出是一个函数, * 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字，不需要大括号包裹 */// import-default.jsimport customName from './export-default';customName(); // 'foo' 比较默认输出和正常输出123456789101112131415// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入/********************************************/// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 12345678910111213141516/* 将默认方法 赋值到 _*/import _ from 'lodash';/* 同时输入默认方法和其他接口 */import _, &#123; each, each as forEach &#125; from 'lodash';// 对应上面代码的export语句如下。export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; // 暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 123456789101112131415161718192021222324252627282930/****************************************/// export和import语句可以结合在一起export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;/****************************************/// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认接口的写法export &#123; default &#125; from 'foo';/****************************************/// 具名接口改为默认接口的写法export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;/****************************************/// 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from './someModule'; 模块的继承假设有一个circleplus模块，继承了circle模块。 12345678910111213// circleplus.js 输出文件export * from 'circle'; // 表示再输出circle模块的所有属性和方法export var e = 2.71828182846; // 又输出了自定义的e变量和默认方法。export default function(x) &#123; // 输出默认方法 return 'test';&#125;export &#123; area as circleArea &#125; from 'circle'; // 只输出circle模块的area方法，且将其改名为circleArea。//main.js 输入文件import * as math from 'circleplus'; // 加载 circleplus 上所有方法import aaa from 'circleplus'; // 将circleplus的默认方法命名为 aaaconsole.log(aaa()); // test 跨模块常量设置跨模块的常量，或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 1234567891011121314151617181920// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo'];/******************************************************/// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users';/******************************************************/// 使用的时候，直接加载 出入该模块，会自动加载其中的 index.js 文件// script.jsimport &#123;db, users&#125; from './constants'; import() 只是有一个 提案，建议引入import()函数，完成动态加载。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合 按需加载 条件加载 动态的模块路径 Module 的加载实现浏览器加载传统方法 123456789101112&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=&quot;application/javascript&quot;&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;&lt;!-- 异步加载的俩种方式 --&gt;&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; // 等到整个页面正常渲染结束，才会执行&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; // 一旦下载完成，立马执行 加载规则 浏览器加载 ES6 模块，也使用 &lt;script&gt; 标签，但是要加入 type=&quot;module&quot; 属性。 12&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;浏览器对于带有type=&quot;module&quot; 都是执行 defer属性的异步加载 与Node相关的ES6 编程风格块级作用域 let 完全取代var let 和 const 之间，优先使用 const 字符串静态字符串一律使用 单引号或反引号，不使用双引号 12345678// badconst a = "foobar";const b = 'foo' + a + 'bar';// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 对象 单行定义的对象，最后一个成员 不以逗号结尾。 多行定义的对象，最后一个成员 以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 数组使用扩展运算符 (…) 拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将伪数组转为真数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数123456789101112131415161718192021222324252627282930313233343536/** * 立即执行函数可以写成箭头函数的形式。 */(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)();/** * 需要使用函数表达式的场合，尽量用箭头函数代替 */[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// 或者[1, 2, 3].map(x =&gt; x * x);/** * 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 */function divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125;/** * 使用rest运算符（...）代替 arguments */function concatenateAll(...args) &#123; return args.join('');&#125;/** * 设置形参默认值。 */function handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 结构 注意区分 Object 和 Map。 如果只是需要key: value的数据结构，使用Map结构。 Class用Class 取代需要 prototype 的操作，因为Class的写法更简洁，更易于理解。 模块 Module 语法是 JS 模块的 标准写法 ，坚持使用这种写法。 使用 import 取代 require。 使用 export 取代 module.exports。 注意事项 如果模块只有一个输出值，才使用export default。 在模块输入中使用通配符，就无法确保有一个默认输出值 模块默认输出一个函数，函数名首字母小写。 模块默认输出一个对象，对象名首字母大写。]]></content>
      <categories>
        <category>这里列出在项目中常用的ES6相关特性，以便更快的理解和应用ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>笔记</tag>
        <tag>ES6笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex]]></title>
    <url>%2F2017-05-30%2Fflex%2F</url>
    <content type="text"><![CDATA[Flex 布局是什么 Flex 是 Flexble Box 的缩写，意为 “弹性布局”，用来为盒状提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局 注意，设为 Flex 布局以后，子元素 的loadt、cleat和vertical-align 将失去作用 12345678910&lt;style type="text/css"&gt; .box&#123; display: flex; &#125; .box&#123; /* 行内元素也可以使用 Flex 布局。 */ display: inline-flex; &#125;&lt;/style&gt; # flex-flow简写：这是flex-direction和flex-wrap两个属性的缩写,默认值是row nowrap。 容器的属性主轴方向：flex-direction: 属性值 属性作用 row（默认）； 从左到右 row-reverse； 从右到左 column； 从上到下 column-reverse； 从下到上 flex-wrap：是否换行 属性值 属性作用 nowrap（默认）； 不换行 wrap； 正常换行 wrap-reverse； 返向换行 justify-content：设伸缩项目在相对 主轴 水平上的对齐方式 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每个项目两侧的间隔相等。 align-content:设伸缩项目在相对 主轴 水垂直的对齐方式 属性值 属性作用 flex-start： 上对齐 flex-end： 下对齐 center： 居中 space-between： 首尾对齐，项目之间的间隔相等。 space-around： 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认）： 每个项目两侧的间隔相等。 align-items：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为auto，将占满整个容器的高度。 # 项目的属性 属性作用 属性值说明 order 数值越小，排列越靠前，默认为0。 flex-grow 定义一个Flex项目的扩大比例，默认为0 flex-shrink 定义一个Flex项目的缩小比例，默认为0 flex-basis 定义了Flex项目在分配Flex容器剩余空间之前的一个默认尺寸，类似width align-self：管理伸缩容器侧轴方向的额外空间 属性值 属性作用 auto 自动 flex-start（默认）： 左对齐 flex-end： 右对齐 center： 居中 baseline: 项目的第一行文字的基线对齐。 stretch（默认）： 如果项目未设置高度或设为auto，将占满整个容器的高度。 简写：flex flex是flex-grow，flex-shrink，flex-basis三个属性的缩写。第二个和第三个参数是可选值。默认值是0 1 auto。 建议使用缩写属性。如果flex取值为none，等于0 0 auto。 参考一 参考二]]></content>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何才能成为很厉害的人]]></title>
    <url>%2F2017-04-13%2Frexue%2F</url>
    <content type="text"><![CDATA[首先，少年，答应别人的承诺，就一定要兑现。 我以前啊，和你一样，很想成为一个很厉害很厉害很厉害的人。 喜欢看热血的东西，幻想自己是屠龙的勇士，登塔的先锋，我左手有剑，右手有光，没头没脑的燃烧自己，敌人的骑军来了，我说你们何人堪与之战，我的女人在等我。 后来我现实了一点，我觉得我要成为那种说走就走，说日就日的男人，我梳大背头，流浪在欧洲或者新几内亚的，我拍孩子，拍野兽，拍流浪的雏妓，与罗伯特德尼罗握手，说嘿，我给你写了愤怒的公牛2。 再后来，我觉得我人生的梦想，是在城市中心买上一间顶层公寓，把一整面墙都改造成钢化玻璃，在灯火通明的夜晚，我就要端着酒站在巨大的窗前，看整个城市在呼吸，然后我的朋友叩门，他带来了一打嫩模，我们就玩一些成年人的游戏现在，我发现龙并不存在，我不会骑马，不会用单反，家住2楼，我能做的，就是把眼前的事儿做好，赚到足够的钱，这样我可以给我的姑娘一个地球仪，然后用飞镖扎它，扎到哪儿，就去哪儿玩。 这样看来，虽然我的想法随着生殖器的发育，始终在变，但那个很厉害很厉害的人，一直离我很远，甚至越来越远。 我心中曾经执剑的少年，此刻也混迹在市井之间。 血似乎都凉了。 我也不是没有惶恐过，是不是我这一生，都不能左手持剑，右手握着罗伯特德尼罗，说这里的嫩模随便你玩但是你他妈别从窗户上掉下去。 这样一看，我逊得不行，我的朋友都是一些凡人，比我还逊，业余生活就是推塔、中单、跪。 我心想，我是不是这辈子都要做一个逊逼，直到我的坟墓上写好墓志铭，我甚至都想好了：我来，我见，我挂了。 最后我给了自己一个否定的答复，我不要。 我喜欢我的朋友们，喜欢我现在的生活，首先我希望你明白，没有厉害与逊逼得区分，只有血的凉与热，有的人觉得生活就这样吧，我算了，现在没什么不好。 有的人觉得生活这样挺好，但是我还要更好。 这种只要剧情稍微热血一点就会热泪盈眶的傻逼，已经不多了，一刻也不要停留。 所以现在，我和你不一样了，我仍然想成为一个很厉害很厉害很厉害的人，像我们这种剧情稍微热血一点就会热泪盈眶的傻逼，要好好珍惜自己。 很多人坐下来了，跟你说你不行，说你省点儿心吧，说你请静一静。 汹涌的人群就把你这样的少年淹没了，人群散去的时候，你也不见了，你那些承诺，谁也听不见，这个世界对于你，就再不可能有什么更有趣更漂亮的女朋友。 你就失约了，小逼崽子。 这么跟你说。 虽然随着年龄的增长，我趋于现实，不能像你那样分分钟冲动的燃烧，然而我每时每刻都有想做的事，有想达成的目标。 不排除以后的某一年，我会握着罗伯特德尼罗的手，他说这是你写得吗，愤怒的公牛2，只要他还没死。 故事里拳王拉莫塔忍着伤，他举着铁拳，挥汗如雨，要和命运斗争，他说我怎么能失约呢，我是那个要成为很厉害很厉害的拳王拉莫塔！小伙儿，成为很厉害很厉害的人，最重要的，就是要热血，永远也不要让你的血凉下去，你凉下去了，就再也不能找到一个更有趣更漂亮的女友，你就失约了，于是那天她踏梦而来，就成了一个彻头彻尾的笑话。 当有一天你成为你讨厌的那种人，浑浑噩噩，你走在街上，看见那些更有趣更漂亮的女孩，你会不会想起多年以前，你说我答应你，在一个承诺就是永远的年纪。 读书，交友，美容，都不如你这一腔狗血，滚烫，灼人，你要燃上大半辈子，才对得起你现在说的这些话。 我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。 火苗再小，你都要反复的点燃。 所谓热血的少年，青涩的爱恋，死亡与梦之约。 这么好的故事。 你可别演砸了。 最后我给你点个人建议： 1.读书，读到倦，网上有很多方法，但你从来沉不下心看。 2.学习，学到疼，网上有很多方法，但你从来沉不下心看。 3.开口说话，冷场也要说话，脸皮薄也要说话，挨打也要说话。 4.如果你现在不知道做什么，至少你还可以先从做一个牛逼的学生开始。 5.更漂亮更有趣的女孩，五年以后再找。 6.承诺是鞭子，不是兴奋剂。 7.年纪大了，也不要说什么心如死灰。 改变自己是非常，非常，非常痛苦的，我能看出来你一腔热血的优点，自然知道你孤僻懒散自以为是的缺点，方法很多，不过我不确定你吃不吃得了苦，我和你共勉吧。 在成为最厉害最厉害最厉害的道路上。 作者：朱炫链接：https://www.zhihu.com/question/22921426/answer/23330366来源：知乎]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quotation]]></title>
    <url>%2F2017-04-09%2Fquotation%2F</url>
    <content type="text"><![CDATA[人不牺牲什么就什么也得不到，为了得到什么就要付出同样的代价，那就是炼金术的等价交换原则，那个时候，我们相信那是世界的真实。出自『钢之炼金术师』 思想中一旦有了依附，骨子里便失去了坚强；出自『网络』 星星之火，可以燎原。出自『张居正』 纸上得来终觉浅，绝知此事要躬行。出自『陆游』 要保持剑的锋利就得时时磨拭，要保持头脑灵光就得看书。出自『乔治·马丁』 俗话说不耻下问是一时之耻，耻而不问是一生之耻。出自『白箱』 累过方得闲，苦过方知甜。出自『网络』 不以物喜，不以己悲。出自『范仲淹』 若有恒，何必三更眠五更起；最无益，莫过一日曝十日寒；出自『毛泽东』 战略上藐视敌人，战术上重视敌人；出自『毛泽东』 人生路很长，永远不要高兴太早。出自『平常心』 人生就像一盒的巧克力，你永远不知道下一块是什么口味。出自『阿甘正传』 如果你不努力，一天比一天容易，但一年比一年难；如果你努力了，一天比一天难，但一年比一年容易。出自『网络』 只有内心强大，才能实现自我救赎；出自『9.18』 富，亦指精神；强，亦指内心；出自『9.18』 人一定要认清自己，自己能干什么，干得了什么，不要人云亦云。出自『★』 对社会不要有太多的抱怨。创业的时候不要把自己当人看。有行动不一定能成功，没有行动就一定失败。出自『俞敏洪』 那家伙永远都是挑战者出自『棒球大联盟』 做没做过的事情是要建立在老老实实的成功之后的基础之上。出自『★』]]></content>
      <categories>
        <category>语录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[photo]]></title>
    <url>%2F2017-04-07%2Fphoto%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017-04-05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[历程还记得在 Github 上生成的第一个page时的新奇还记得在 CSDN 的第一次开通博客的 Hello world 的兴奋如今在Github的page上生成了自己的博客，那可谓是即新奇 + 兴奋带来的激动可以在自己的这块领地为所欲为，光想想就有一种迎风而来的酸爽 致敬每一次的开始都仿佛打开一扇门而每扇门的背后都有着无数默默付出和无私奉献的人是他们让现在的这个圈子有了生态没有他们的付出我不会这么顺利的把这个博客搭建起来再次由衷的致敬这些人我愿成为向你们一样的人]]></content>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 域名绑定]]></title>
    <url>%2F2017-03-09%2Fwwwyuming%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也讲过了，我们把博客同时托管到 Github 和 Coding。我们就有两个域名可以访问站点，但是又出现几个问题：使用的不是自己的域名；两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并；github pages国内访问速度慢（300ms左右，毕竟国外的服务器）。 这就有点坑爹了，强迫症怎么能忍。下面给出解决方法。。 解决方案：我们知道 github 和 coding 的 pages 服务都提供 自定义域名 功能。我们可以利用这一点，绑定自己的域名。域名解析的时候实现国内访问 coding pages ，国外访问 github pages ,从而加快访问速度。 具体怎么实现，往下看： 购买域名首先我们要购买一个域名，推荐到 万网 购买。（毕竟很方便）具体步骤可以参考这篇文章：万网域名注册教程。 购买域名一定要实名认证，否则会停止解析 域名解析这一步是最重要的，我们要把域名指向 github 和 coding 的服务器空间。 登录阿里云，进入 控制台 。依次点击 域名与网站 &gt; 云解析DNS 就会出现你购买的域名信息 点击 解析，然后按照下图依次添加解析：（这张图片可以放大） 从上图可以看出，我们的解析实现了分流。国内线路访问Coding pages，国际线路访问Github Pages。 托管平台设置Coding平台进入对应项目的 pages 设置页面（项目 &gt; 代码 &gt; pages服务） 成功后会显示： Github平台进入对应项目的 pages 设置页面（setting &gt; github pages &gt; Custom domain) 成功后会显示： 到此我们的博客就可以正常运行了！！ 总结一切搞定后，在回头看一下我们的问题：@ 两个地址的统计信息（文章阅读量，访问量等）相互独立，不能合并； 从两个地址访问都会跳转到我们绑定的域名。统计信息自然也是绑定后域名的信息。 @ github pages国内访问速度慢（300ms左右） 我们测试一下 Ping：(表现不错) @ 托管平台给出的二级域名太丑。 不存在的…..]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 博客同时部署到 GitHub 和 Coding]]></title>
    <url>%2F2017-03-08%2Fgithub%E5%92%8Ccoding%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人都把 hexo 托管到 Github 上，因为 Github 大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问 coding 比 github 是要快不少的。还可以利用域名解析实现国内的走 coding，海外的走github，分流网站的访问。 注册GitHub和Codinggithub官网 &nbsp;&nbsp;||&nbsp;&nbsp; Coding官网 &nbsp;&nbsp;注册就不必多说，不会的可自行百度。需要注意的是：最好使用同一个 用户名 和 邮箱 ，以免引起不必要的麻烦。 创建项目在GitHub上创建项目，名称为：yourname.github.io在Coding上创建项目，名称为：yourname 配置SSH配置 shh key 是让本地 git 项目与远程的 github 建立联系 获取ssh 检查是否已经有SSH Key，打开 Git Bash，输入 1cd ~/.ssh 如果没有 .ssh 这个目录，则生成一个新的 SSH，输入 1ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意: 此处的邮箱地址，是你注册 GitHub 和 coding 时的邮箱地址; 此处的「-C」的是大写的「C」 。 接下来几步都直接按回车键,然后系统会要你输入密码 (防止别人往你的项目里提交内容) 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 成功后，我们打开 C:\Users\cwyaml.ssh 打开 id_rsa.pub 文件。里面的代码就是 ssh key。 添加 SSH Key 到 GitHub 和 CodingGitHub添加方法： 进入Github官网，点击头像，再按 settings 进入设置。 点击 New SSH key 创建 title输入邮箱，key里面粘贴刚才右击复制的内容,再点 Add SSH key 即可。（会让你输入密码） Coding添加方法： 登录账号后点击 左侧账户 在点 SSH公钥 设置即可 。（同样要输入密码） 测试SSH是否配置成功打开 Git Bash，首先测试 GitHub 是否成功？输入:1ssh -T git@github.com (如配置了密码则要输入密码,输完按回车。)如果显示以下内容，则说明 Github 中的 ssh 配置成功。12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 然后测试 Coding 是否成功？1ssh -T git@git.coding.net 如果显示以下则说明配置成功：1Hello username You&apos;ve connected to Coding.net by SSH successfully! 上传博客文件修改站点配置文件：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:cwyaml/cwyaml.github.io.git,master coding: git@git.coding.net:cwyaml/cwyaml.git,master 然后你就可以 hexo c、hexo g、hexo d 了。 开启pages服务GitHub 已经默认开启，就不必多说了。Coding 进入对应项目，点击 代码&gt;pages服务 ，把部署来源改为 master 即可。 访问博客这样我们整个部署过程就完成了。有两个地址可以访问我们的博客：GitHub pages：https://cwyaml.github.ioCoding pages：https://cwyaml.coding.me]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 备份]]></title>
    <url>%2F2017-03-07%2Fbackup%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用Hexo写博客是一件比较享受的事情，无奈如果换电脑或者系统崩了的话，你就会一脸懵B了，备份博客就显得尤为重要。先说说我的感受，博客刚搭建好的时候就想过这个问题，那时候对 git 似懂非懂吧。在网上找了很多教程方法，大概就是说要创建一个分支来存放 blog 文件，但是翻腾来翻腾去还是没有搞定。 最后索性简单粗暴点，在 GitHub 上创建一个仓库，把 blog 文件整个打包上传。使用过程中发现这个方法还不错，至少对于小白来说很容易理解，也很难出错，就一直沿用到现在。 这种方式虽然能够备份 Hexo 博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。 自动备份准备本方法需要提前将 Hexo 加入 Git仓库 并与 Github 远程仓库绑定之后，才能正常工作。具体做法可以参考：上传本地项目到GitHub 安装 shelljs 模块要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块,该模块重新包装了 child_process,调用系统命令更加的方便。使用以下命令，完成 shelljs 模块的安装：1npm install --save shelljs 编写自动备份脚本待到模块安装完成，在Hexo根目录 的 scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个。123456789101112131415161718192021222324252627282930require(&apos;shelljs/global&apos;);try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;C:/Blog&apos;); //此处修改为Hexo根目录路径 if (exec(&apos;git add .&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -m &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin master&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 注意： 其中，需要修改第17行的 D:/hexo 路径为 Hexo的根目录 路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为 origin 的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 测试保存脚本并退出，然后执行 hexo d 命令，将会得到类似以下结果:12345678910111213141516171819202122232425262728293031323334353637383940INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder.........======================Auto Backup Begin===========================warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/hexo1.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/update to github.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/wangyimusic.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in themes/next-5.0.1/layout/_partials/head.swig.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/backup.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/encrypt.md.The file will have its original line endings in your working directory.[master 1bb6cc5] Form auto backup script&apos;s commit Committer: unknownYour name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly. Run thefollowing command and follow the instructions in your editor to edityour configuration file: git config --global --editAfter doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 6 files changed, 177 insertions(+), 2 deletions(-) create mode 100644 scripts/autobackup.js create mode 100644 source/_posts/backup.md create mode 100644 source/_posts/encrypt.mdTo https://github.com/cwyaml/blog-backup.git d7bc718..1bb6cc5 master -&gt; master==================Auto Backup Complete============================ 这样子，每次更新博文并 deploy 到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？ Enjoy it！ 参考：wanghao大神 自动备份Hexo博客源文件]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
        <tag>backup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你制作音乐外链]]></title>
    <url>%2F2017-03-02%2Fwangyimusic%2F</url>
    <content type="text"><![CDATA[本篇文章讲怎样制作音乐外链，我主要用来为自己的博客添加背景音乐。（其实主要用来装X） 通用方法首先你需要下载想要的歌曲：QQ音乐、网易云音乐需要安装客户端才能下载。虾米音乐可以在网页直接下载。总之把需要的歌曲下载下来就可以了！！ 我们利用 七牛云存储 来自动生成歌曲外链。第一步：注册、登录第二步：在对象存储中新建一个仓库，命名为 music 。第三步：在内容管理中上传歌曲文件 用这种方法所有歌曲（只要能下载）都能获得，并且永久有效 网易云音乐获取方法第一步： 先获取歌曲id，直接打开网易云音乐网页版: http://music.163.com搜索自己喜欢的音乐，并获取歌曲的 ID 。举个例子：（id很明显吧） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://music.163.com/#/song?id=443205403 第二步： 将下面网址中的两处id替换成的歌曲idhttp://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token=你将会获得一大串代码：外链就隐藏其中。。找不到的话就把这段代码复制到编辑器里，ctrl+F 查找 .mp31234567891011121314&#123;&quot;songs&quot;:[&#123;&quot;name&quot;:&quot;原来都是梦 &quot;,&quot;id&quot;:425137664,&quot;position&quot;:1,&quot;alias&quot;:[],&quot;status&quot;:0,&quot;fee&quot;:0,&quot;copyrightId&quot;:0,&quot;disc&quot;:&quot;&quot;,&quot;no&quot;:1,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p4.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;album&quot;:&#123;&quot;name&quot;:&quot;原来都是梦&quot;,&quot;id&quot;:34816208,&quot;type&quot;:&quot;EP/Single&quot;,&quot;size&quot;:2,&quot;picId&quot;:3432675310535810,&quot;blurPicUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;companyId&quot;:0,&quot;pic&quot;:3432675310535810,&quot;picUrl&quot;:&quot;http://p3.music.126.net/LNL0l5xhstsgIILEaVkprg==/3432675310535810.jpg&quot;,&quot;publishTime&quot;:1470844800007,&quot;description&quot;:&quot;&quot;,&quot;tags&quot;:&quot;&quot;,&quot;company&quot;:&quot;百纳娱乐&quot;,&quot;briefDesc&quot;:&quot;&quot;,&quot;artist&quot;:&#123;&quot;name&quot;:&quot;&quot;,&quot;id&quot;:0,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;,&quot;songs&quot;:[],&quot;alias&quot;:[],&quot;status&quot;:0,&quot;copyrightId&quot;:0,&quot;commentThreadId&quot;:&quot;R_AL_3_34816208&quot;,&quot;artists&quot;:[&#123;&quot;name&quot;:&quot;李行亮&quot;,&quot;id&quot;:4093,&quot;picId&quot;:0,&quot;img1v1Id&quot;:0,&quot;briefDesc&quot;:&quot;&quot;,&quot;picUrl&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;img1v1Url&quot;:&quot;http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;,&quot;albumSize&quot;:0,&quot;alias&quot;:[],&quot;trans&quot;:&quot;&quot;,&quot;musicSize&quot;:0&#125;],&quot;subType&quot;:&quot;录音室版&quot;&#125;,&quot;starred&quot;:false,&quot;popularity&quot;:100.0,&quot;score&quot;:100,&quot;starredNum&quot;:0,&quot;duration&quot;:262500,&quot;playedNum&quot;:0,&quot;dayPlays&quot;:0,&quot;hearTime&quot;:0,&quot;ringtone&quot;:null,&quot;crbt&quot;:null,&quot;audition&quot;:null,&quot;copyFrom&quot;:&quot;&quot;,&quot;commentThreadId&quot;:&quot;R_SO_4_425137664&quot;,&quot;rtUrl&quot;:null,&quot;ftype&quot;:0,&quot;rtUrls&quot;:[],&quot;copyright&quot;:0,&quot;rurl&quot;:null,&quot;mvid&quot;:0,&quot;rtype&quot;:0,&quot;bMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;,&quot;mp3Url&quot;:&quot;http://m2.music.126.net/eU871p87-mpm5JcrqnsP2w==/1413971967605233.mp3&quot;,&quot;hMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538621,&quot;size&quot;:10502313,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605231,&quot;bitrate&quot;:320000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.63&#125;,&quot;mMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538622,&quot;size&quot;:5251179,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605232,&quot;bitrate&quot;:160000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.19&#125;,&quot;lMusic&quot;:&#123;&quot;name&quot;:null,&quot;id&quot;:1225538623,&quot;size&quot;:3150725,&quot;extension&quot;:&quot;mp3&quot;,&quot;sr&quot;:44100,&quot;dfsId&quot;:1413971967605233,&quot;bitrate&quot;:96000,&quot;playTime&quot;:262500,&quot;volumeDelta&quot;:-2.21&#125;&#125;],&quot;equalizers&quot;:&#123;&#125;,&quot;code&quot;:200&#125; 第三步： 将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！！ 用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 使用中常见的问题及解决方法]]></title>
    <url>%2F2017-02-14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像 Markdown 官方文档里描述的一样：可读性，无论如何，都是最重要的。 Markdown 的目标是实现 &nbsp; 『易读易写』 。&nbsp;Markdown 从发布到现在备受好评，经过这一段的使用，整体感觉挺顺手，不过还是存在很多问题，所以总结一下喽。。 编辑器其实自己喜欢的才是最好的。(像 vim 、emacs什么的不推荐，因为我也不会用) MAC平台自己没用过，不做推荐。你可以看看这个帖子：Mac 上适合码农用的 Markdown 编辑器是什么？ Windows平台印象笔记马克飞象传送门，界面不是很好看，书写的时候感觉很别扭 有道云笔记有道传送门，同样很丑，强迫症受不了 Sublime Text强大的 Sublime Text 总是能给我们很多惊喜，经过各种对比，sublime 满足了我对审美的要求。首先我们需要安装两个插件：（至于怎么安装就不说了） markdownEditing 用来书写 markdownPreview 用来预览 Atom（强烈推荐）GitHub 推出的编辑器，界面很好（就是启动有点慢），必须支持一下。默认继承了 markdown 预览，快捷键为 Ctrl+shift+M。推荐插件： markdown-preview 实时预览 markdown-scroll-sync 编辑区和预览区同步滚动 markdown-writer 方便管理图片链接等 markdown-table-formatte 表格格式化 使用方法Markdown官方文档 常见问题汇总html标签显示比如说我要写一篇博客，标题为“html中 &lt;canvas&gt; 的使用”1## html中 &lt;canvas&gt; 的使用 如果这样写就会出现排版上的问题（不信你试一下），那么怎么解决呢？其实认真想一下就能明白，Markdown 的语法是基于 html 的，我们直接写 &lt;canvas&gt;，自然会被理解为一个标签，而不是要显示的文本。。所以，问题回归到 html 上。在网页中，我们要显示 &lt;canvas&gt; 时要用到 转义字符, 所以 Markdown 中也一样，我们应该这样写：1## html中 &amp;lt;canvas&amp;gt; 的使用 代码语法高亮这个问题困扰了我好久，官方文档里竟然没有说明！只好自己去查找方法。Markdown 中显示代码块是这样的格式：显示为：1&lt;p&gt;这是一个p标签&lt;/p&gt; 而我们这样写：就可以实现代码高亮了1&lt;p&gt;这是一个p标签&lt;/p&gt; 据说这种方式一共支持四十多种语言，有兴趣的话你可以研究一下。 图片Markdown 中嵌入图片，如果使用本地图片就要用到 html 标签来引用，这种方法很稳定，但是使文档变得很大（一张图片最少几百k吧）。所以我们要用到 图床 。 贴图库推荐使用 &nbsp; 贴图库 &nbsp;快速，免费（我使用过程中没掉过链子） 注册登录，就可以上传图片，每张图片自动生成 原图、展示图和 缩略图的图片外链、html代码、Markdown外链等。只要把对应的代码粘贴到你的文档中就可以了。。 七牛云存储这个最近很火，可靠、可扩展、低成本等等有很多优点。你可以试一下。我们主要用到他的 对象存储 服务，创建一个公开仓库，把图片上传就可以生成外链了。 gifGithub 上的开源项目，ReadMe.md 是也支持 Markdown 语法的，通常会看到很多开源项目的 ReadMe 中有 动态演示效果，看到这个项目的人一目了然，非常方便，gif本身也是一种图片格式，在 Markdown 中 引用时和正常图片的引用一样，但需要专门的工具生成 gif 格式的图片才行，在这里强烈推荐 LICEcap，它是一款 windows 上的录屏软件，录制后保存的格式为 gif，体积小并且同样也可以在图床上生成链接。 插入音乐你可以把音乐文件下载到本地，然后简单粗暴的使用 html 中的 &lt;video&gt; 标签。当然，如果这样就不必写下去了，告诉你简单的方法：网易云音乐 打开网易云音乐网页版，搜索自己喜欢的音乐，比如我找到 告白气球 我们可以看到在图片的下边有一个 生成外链播放器 , 点击会出现 选择 合适的尺寸 和 播放模式 之后。把下边的代码复制到你的 Markdown 文档中就可以了。试着听一下吧！！(我选择了最小尺寸) 试着去把一个 歌单生成外链播放器 插入到你的 Markdown 中，这样你跟新歌单你的博文也会跟着变化，而不必在想跟换歌曲时头疼]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单博文加密]]></title>
    <url>%2F2017-02-07%2Fencrypt%2F</url>
    <content type="text"><![CDATA[即使是最简单的加密方式也足以阻止90%的访问者 原理由于 Hexo 最终编译出来的是静态文件，也就意味着文章的所有信息会原封不动展示在页面中，当你输入一篇文章的地址，所有的内容就已经跟随网络传输过来了。那么博客使用加密是怎么实现的呢？ 这就要讲到 js 的阻塞机制了，当调用 alert(); 函数的时候，整个页面会停止运行，直到你点击确定之后，才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是 alert(); 只有提醒的功能，没有输入的功能，所以，这里要用到的是 promt() 方法。 promt()方法介绍这个 promt() 方法有什么作用呢？查看js文档可以知道： prompt()方法 : 用于显示可提示用户进行输入的对话框。如果用户单击提示框的 取消 按钮，则返回 null。如果用户单击 确认按钮，则返回 输入字段当前显示的文本（用户输入的文本）。 我们就是利用 promt() 方法可以返回用户输入的文本这个特性，获取到返回数据，与我们设置的密码进行验证，从而实现文档加密的。。 实践找到 themes\next\layout\_partials\head.swig 文件。在 &lt;meta&gt; 标签之后添加以下代码：12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 这里有必要解释一下 page.password 是什么东西。以下我给出这篇文章的头部参考：首先 page 是一个变量，你可以理解为这篇文章。以下面的代码为参考，那么 page.title = 最简单的翻墙方法; page.comments = fasle;（很好理解吧） 123456title: 最简单的翻墙方法date: 2017-03-01 12:01:05tags: [翻墙,hosts]categories: [外面的世界]keywords: 翻墙,hostscomments: false 所以，要想加密博文，我们要为文章加上 password 属性。description 属性用于对文章进行描述。（加密下显示内容）12description: 文章访问密码：passwordpassword: password 总结这种方式只能说是一点小技巧的应用吧，在大神面前可能不管用，但足以阻挡大多数用户。更完美的博文加密方式请参考：加密博客内容，使用密码访问]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub搭建博客 - 优化]]></title>
    <url>%2F2017-01-25%2Fhexo2%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍基于NexT主题的一些第三方功能的实现。基本功能的设置可以参考Next官网文档 首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件 ，后者称为 主题配置文件。 背景动态背景修改 _layout.swig 模板模板位置：themes\next\layout\_layout.swig在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）12345&lt;!-- 动态背景 --&gt;#默认灰色线条&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;#浅蓝色线条&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"&gt;&lt;/script&gt; 然后在 themes\source\js\src\ 下新建文件 particle.js 写上以下代码:1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 鼠标点击小红心在 \themes\next\source\js\src 文件目录下添加 love.js 文件。内容为：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 头像圆形旋转修改文件 themes/next/source/css/_common/components/sidebar/sidebar-author.styl我的样式文件 文章结尾模板在 \themes\next\_macro 文件目录下添加 passage-end-tag.swig 文件，内容为：(当然你也可以修改为自己喜欢的样式)1234567891011121314&#123;% if theme.passage_end_tag.enabled %&#125;&lt;blockquote class="blockquote-center"&gt; &lt;p&gt;如果您觉得本博客还不错，欢迎继续关注本博客，欢迎多提宝贵意见，非常感谢！&lt;/p&gt;&lt;/blockquote&gt;&lt;span id="inline-green" style="border-radius:3px;"&gt;作者&lt;/span&gt;：&lt;a class="link-blue" href="https://github.com/cwyaml" target="_blank"&gt;cwyaml&lt;/a&gt;有问题请 &lt;a class="link-blue" href="https://cwyaml.github.io/about/"&gt;留言&lt;/a&gt; 或者私信我的 &lt;a class="link-blue" href="http://weibo.com/u/5742789641?refer_flag=1001030102_&amp;is_all=1" target="_blank"&gt;微博&lt;/a&gt;。&lt;div style="text-align:center; color:#ccc; font-size:14px; "&gt; ------本文结束 &amp;nbsp;&lt;i class="fa fa-paw"&gt;&lt;/i&gt;&amp;nbsp; 感谢阅读------&lt;/div&gt;&#123;% endif %&#125; 找到 \themes\next\_macro\post.swig 文件，使用查找功能找到 reward.swig，在这一个 &lt;div&gt; 的前面添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 文章底部标签云锚点在 themes\next\layout\_macro\post.swig 文件中找到以下代码：12345678910&lt;footer class="post-footer"&gt;&lt;!--这是文章底部标签云锚点，不喜欢就注释掉 &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;--&gt; 关于文章内文本样式Markdown 毕竟是为了方便写作，在样式上就过于单调。我们自己来给文章加一些样式。。 Next 作者提供了一个供用户自己定义样式的文件：\themes\next\source\css\_custom\custom.stl 自己按需要写在上述文件中写上自己的 class 类，然后在 Markdown 文档中使用。我的custom.styl 引用前端框架目前流行的前端框架，像 bootstrap、React、Angular 等，提供给我们很好的前端方案，我们可以把喜欢的引入到上面说的那个文件里，然后就可以使用了。 设置动态title 在 \themes\next\source\js\src 目录下新建 dytitle.js 。添加以下内容： 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos; 页面崩溃啦 ~ | cwyaml！&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos; 噫又好了~ &apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); 更改 \themes\next\layout\_layout.swig 。在 &lt;/body&gt; 之前添加： 12&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt; 首页动画在 主题配置文件 中，找到 Motion 字段。true 和 false 控制动画的开启与关闭。12# Motionuse_motion: true 内容宽度现在一般的笔记本都在15寸以上，博客页面两侧留白太多就显得没有必要，并且不美观，所以有必要调整一下宽度。（可以慢慢试着调整到最合适的状态） 找到 \themes\next\source\css\_common\components\post\post-expand.styl，找到： 123@media (max-width: 767px)改为：@media (max-width: 1060px) 找到：\themes\next\source\css\ _variables\base.styl ，找到： 123456789$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px改为：$main-desktop = 1060px$main-desktop-large = 1200px$content-desktop = 800px 找到 \themes\next\source\css\_schemes\Pisces\_layout.styl ，将第 4 行的 width 改为 1060px ，修改后如下： 1234.header &#123; position: relative; margin: 0 auto; width: 1060px; 统计功能文章阅读次数统计参考： LeanCloud 不蒜子统计站点访问 全局配置：编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：当 enable: true 时，代表开启全局开关。若 site_uv、site_pv、page_pv 的值均为 false 时，不蒜子仅作记录而不会在页面上显示。 站点 UV/PV 配置：当 site_uv: true 时，代表在页面底部显示站点的 UV 值。当 site_pv: true 时，代表在页面底部显示站点的 PV 值site_uv_header(site_pv_header) 和 site_uv_footer(site_pv_footer) 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为 [site_uv_header]UV值/PV值[site_uv_footer]。 1234567891011busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站总访问量 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: 您是第 site_pv_footer: 位小伙伴 单页面 PV 值设置： 1234# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址（放在博客根目录的source文件夹下即可） 即可开启该功能。123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /weixin.pngalipay: /zhifubao.png 设置RSS 需要安装 hexo-generator-feed 插件。 1$ npm install hexo-generator-feed --save 在 站点配置文件 中添加字段： 123456feed: type: atom path: atom.xml limit: 20 hub: content: 听音乐 下载js文件：high.swig。放在 \themes\next\layout\_macro 目录下。 在侧边栏引用该文件：修改 \themes\next\layout\_macro\sidebar.swig ，添加以下代码： 1&#123;% include &apos;high.swig&apos; %&#125; 样式修改：使 听音乐 和 RSS 并排展示，修改 \themes\next\source\css\_schemes\Pisces\_sidebar.styl 1display: inline-block; 添加自己喜欢的音乐：修改其中的歌曲链接即可（获取歌曲外链教程） 123456var songs = [ "http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3", "http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3", "http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3", "......" ]; 首页听音乐摇晃：需要加载css样式。在 themes\next\layout\_layout.swig 文件的 body标签结束前 添加以下代码： 12&lt;!-- 听音乐摇晃 --&gt;&lt;link href="http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css" rel="stylesheet" type="text/css"&gt; 注意： 有时候使用 Firefox 、Chrome时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 \themes\next\source\css\_custom\custom.stl 文件即可解决。 添加 Forkme on GitHub 丝带首先进入 GitHub Ribbons 选择自己喜欢的丝带样式。找到 \themes\next\layout\_layout.swig 文件，在 &lt;header&gt; 标签前面添加：（记得把链接修改成自己的GitHub主页）1&lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"&gt;&lt;/a&gt; 给 Blog 添加 LICENSE修改 主题配置文件 （使用查找功能）12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: Local Search 安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件 ，添加以下字段： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索 123# Local searchlocal_search: enable: true 多说多说评论使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择“我要安装”。 创建站点，填写站点相关信息。多说域名 这一栏填写的就是你的 duoshuo_shortname, 创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值即可。 多说评论框自定义 : 我的样式代码 多说分享在 主题配置文件 中设置：12# Shareduoshuo_share: true 禁用鼠标经过时分享更多功能（有bug）:找到 \themes\next\layout\_partials\share\duoshuo_share.swig 文件，替换内容为：123456789101112131415161718&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;" data-title="&#123;&#123; page.title &#125;&#125;" data-content="" data-url="&#123;&#123; page.permalink &#125;&#125;"&gt; &lt;div class="ds-share-inline"&gt; &lt;ul class="ds-share-icons-16"&gt; &lt;li&gt;&lt;span class="ds-more"&gt;分享到：&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-weibo" href="javascript:void(0);" data-service="weibo"&gt;微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qzone" href="javascript:void(0);" data-service="qzone"&gt;QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-qqt" href="javascript:void(0);" data-service="qqt"&gt;腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-wechat" href="javascript:void(0);" data-service="wechat"&gt;微信&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-facebook" href="javascript:void(0);" data-service="facebook"&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class="ds-google" href="javascript:void(0);" data-service="google"&gt;Google&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="ds-share-icons-more"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp插件。hexo-all-minifier 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。 hexo-all-minifier 使用方法安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 hexo-all-minifier glup 使用方法hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;amp;&amp;amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶 修改 hexo-generator-index 插件。替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：1234567---title: cwyaml 图集categories: [图片]tags: [picture]date: 2015-04-02 14:36:04top: 10--- 博文部署 message在 \node_modules\hexo-deployer-git\lib\deployer.js 文件末尾找到这一句：（记得个性一点）1Lucky Boy: &#123;&#123; now(\&apos;YYYY-MM-DD HH:mm:ss\&apos;) &#125;&#125;. 图片模式 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址，如下所示：(其中的 x-x 为图片展示效果，可以自己尝试一下) 123456789101112131415---title: Naruto-Picturescategories: [图片]tags: [picture]date: 2014-06-02 10:36:02type: "picture"comments: false---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub,搭建博客 - 配置]]></title>
    <url>%2F2016-12-24%2Fhexo1%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍怎样利用 Hexo + Next 在 GitHub 上搭建个人博客。 简介&nbsp;&nbsp;Hexo 是一个快速、简洁且高效的静态站点生成框架，基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 &nbsp; 精于心，简于形 &nbsp; 的风格，一直被广大用户所喜爱。 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，跳过这一步。如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Now windows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。（执行完以后，我们同样可以执行命令 hexo -v 查看是否安装成功就安装成功了。）1$ npm install -g hexo-cli Hexo安装完成后，我们需要为我们的blog项目创建一个指定文件夹（例如我在 D 盘根目录下创建了一个文件夹 blog 。D:\blog ），在该文件夹中执行以下命令， Hexo 将会在指定文件夹中新建所需要的文件。12$ hexo init$ npm install 等待安装，安装完成后，指定文件夹 的目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令12$ hexo g //编译$ hexo s --debug //开启本地服务 这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 到目前为止我们的本地博客已经部署完成。下面我们换上Next主题。 使用Next主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 启用 NexT 主题打开 站点配置文件 (Hexo文件夹下的_config.yml文件)，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们依次执行以下命令验证主题是否正确启用。 123$ hexo clean$ hexo g$ hexo s 我们在浏览器中访问 http://localhost:4000/ ，你将看到： 总结本地调试三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带debug的运行，如果出现错误，可以在命令行中看到错误提示信息。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Next+Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>